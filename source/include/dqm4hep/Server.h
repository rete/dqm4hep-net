/// \file Server.h
/*
 *
 * Server.h header template automatically generated by a class generator
 * Creation date : sam. dï¿½c. 3 2016
 *
 * This file is part of DQM4HEP libraries.
 *
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 *
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

#ifndef SERVER_H
#define SERVER_H

// -- dqm4hep headers
#include <dqm4hep/NetBuffer.h>
#include <dqm4hep/RequestHandler.h>
#include <dqm4hep/Service.h>
#include <dqm4hep/Signal.h>

// -- dim headers
#include <dis.hxx>

namespace dqm4hep {

  namespace net {
    
#ifdef true

    namespace experimental {
      
      class Server;
      
      class NameServerData {
      public:
        /// The data buffer to handle
        Buffer            m_data = {};
        /// The service name (command, request or service)
        std::string       m_name = {""};
        /// The client id
        int               m_clientId = {0}; 
      };
      
      class NameServer {
        class Service;
        class Command;
        class Rpc;
      public:
        inline NameServer(Server *srv) :
          m_server(srv) {
          /* nop */
        }
        
        inline ~NameServer() {
          
        }
        
        NameServer(const NameServer&) = delete;
        NameServer() = delete;
        NameServer& operator=(const NameServer&) = delete;
        
        inline const std::string& name() const {
          return m_name;
        }
        
        inline void setName(const std::string &sname) {
          if(running()) {
            dqm_error("NameServer::setName: Already running, can't set server name !");
            throw core::StatusCodeException(core::STATUS_CODE_NOT_ALLOWED);
          }
          m_name = sname;
        }
        
        inline void start() {
          if(running()) {
            return;
          }
          // TODO start server impl
          m_running = true;
        }
        
        inline void stop() {
          if(not running()) {
            return;
          }
          // TODO start server impl
          m_running = false;
        }
        
        inline bool running() const {
          return m_running;
        }
        
        // SVC
        inline void createService(const std::string &svcName) {
          if(serviceExists()) {
            dqm_error("NameServer::createService: Service '{0}' already exists", svcName);
            throw core::StatusCodeException(core::STATUS_CODE_ALREADY_PRESENT);
          }
          // TODO create service impl
        }
        
        inline void removeService(const std::string &svcName) {
          if(not serviceExists()) {
            return;
          }
          // TODO remove service impl
        }
        
        inline bool serviceExists(const std::string &svcName) const {
          return true; // TODO impl
        }
        
        template <typename T>
        inline void updateService(const std::string &svcName, int clientId, const T& data) {
          NameServerData sdata;
          sdata.m_client = clientId;
          sdata.m_name = svcName;
          auto model = sdata.m_data.createModel();
          model.copy(data);
          sdata.m_data.setModel(model);
          // do it
          updateService(sdata);
        }
        
        template <typename T>
        inline void updateService(const std::string &svcName, int clientId, const T *const array, std::size_t size) {
          NameServerData sdata;
          sdata.m_client = clientId;
          sdata.m_name = svcName;
          auto model = sdata.m_data.createModel();
          model.adopt(array, size*sizeof(T));
          sdata.m_data.setModel(model);
          // do it
          updateService(sdata);
        }
        
        template <typename T>
        inline void updateService(const std::string &svcName, const T& data) const {
          NameServerData sdata;
          sdata.m_client = 0;
          sdata.m_name = svcName;
          auto model = sdata.m_data.createModel();
          model.copy(data);
          sdata.m_data.setModel(model);
          // do it
          updateService(sdata);
        }
        
        template <typename T>
        inline void updateService(const std::string &svcName, const T *const array, std::size_t size) const {
          NameServerData sdata;
          sdata.m_client = 0;
          sdata.m_name = svcName;
          auto model = sdata.m_data.createModel();
          model.adopt(array, size*sizeof(T));
          sdata.m_data.setModel(model);
          // do it
          updateService(sdata);
        }
        
        // RPC
        template <typename T>
        void onRequest(const std::string &name, T *obj, void(T::*func)(const NameServerData &data, Buffer &response));
        
        // CMD
        template <typename T>
        void onCommand(const std::string &name, T *obj, void(T::*func)(const NameServerData &data));
        
        template <typename T>
        void onClientExit(T *obj, void(T::*func)(int clientId));
        
        template <typename T>
        void cleanup(T *obj);
        
      private:
        void updateService(const NameServerData &/*data*/) {
          
        }
        
      private:
        Server*                   m_server = {nullptr};
        std::string               m_name = {"main"};
        bool                      m_running = {false};
      };
      
      class Server {

      public:
        Server();
        ~Server();
        Server& operator=(const Server&) = delete;
        Server(const Server&) = delete;
        
        // name server stuff
        void enableNameServer();
        void disableNameServer();
        bool nameServerEnabled() const;
        const NameServer* nameServer() const;
        NameServer* nameServer();

        
        // websocket stuff
        void enableWebsocketServer();
        void disableWebsocketServer();
        void setPort(int port);
        int port() const;
        
        
        
      };
      
    }
#endif

    /**
     * Server class
     *
     * Main interface for service and request handler registration.
     * User can create services using the createService() method.
     * Request from client side can be handled by registering a
     * request handler by providing a class method to handle the
     * request and fill a reponse.
     *
     * All created services and request handlers are started after
     * server startup.
     */
    class Server : public DimServer {
    public:
      /**
       *  @brief  Constructor
       *
       *  @param  name the server name
       */
      Server(const std::string &name);
      Server() = delete;
      Server(const Server&) = delete;
      Server& operator=(const Server&) = delete;

      /**
       *  @brief  Destructor
       */
      ~Server() override;

      /**
       *  @brief  Get the server name
       */
      const std::string &name() const;

      /**
       * @brief  Start serving services and handling requests
       */
      void start();

      /**
       *  @brief  Stop serving services and handling requests
       */
      void stop();

      /**
       *  @brief  Whether the server is running
       */
      bool isRunning() const;

      /**
       *  @brief  Close all service and request handlers.
       *          Called from destructor
       */
      void clear();

      /**
       *  @brief  Create a new service.
       *
       *  @param  name the service name
       */
      Service *createService(const std::string &name);

      /**
       *  @brief  Create a new request handler
       *
       *  @param  name the request handler name
       *  @param  pController the class instance that will handle the request
       *  @param  function the class method that will treat the request and provide a response
       */
      template <typename Controller>
      void createRequestHandler(const std::string &name, Controller *pController,
                                void (Controller::*function)(const Buffer &request, Buffer &response));

      /**
       *  @brief  Create a new command handler
       *
       *  @param  name the command handler name
       *  @param  pController the class instance that will handle the command
       *  @param  function the class method that will treat the command
       */
      template <typename Controller>
      void createCommandHandler(const std::string &name, Controller *pController,
                                void (Controller::*function)(const Buffer &command));

      /**
       *  @brief  Whether the target service is registered in this server
       *
       *  @param  name the service name
       */
      bool isServiceRegistered(const std::string &name) const;

      /**
       *  @brief  Whether the request handler is registered in this server
       *
       *  @param  name the request handler name
       */
      bool isRequestHandlerRegistered(const std::string &name) const;

      /**
       *  @brief  Whether the command handler is registered in this server
       *
       *  @param  name the command handler name
       */
      bool isCommandHandlerRegistered(const std::string &name) const;

      /**
       *  @brief  Start a target service
       *
       *  @param  name the service name
       */
      void startService(const std::string &name);

      /**
       *  @brief  Stop a target service
       *
       *  @param  name the service name
       */
      void stopService(const std::string &name);

      /**
       *  @brief  Start a target request handler
       *
       *  @param  name the request handler name
       */
      void startRequestHandler(const std::string &name);

      /**
       * @brief  Stop a target request handler
       *
       *  @param  name the request handler name
       */
      void stopRequestHandler(const std::string &name);

      /**
       *  @brief  Start a target request handler
       *
       *  @param name the command name
       */
      void startCommandHandler(const std::string &name);

      /**
       *  @brief  Stop a target command handler
       *
       *  @param  name the command handler name
       */
      void stopCommandHandler(const std::string &name);

      /**
       *  @brief  Stop a specific command handler
       *
       *  @param  name the command handler name
       *  @param  pController the command handler controller
       */
      template <typename Controller>
      void stopCommandHandler(const std::string &name, Controller *pController);

      /**
       *  @brief  Stop a specific command handler
       *
       *  @param  name the command handler name
       *  @param  pController the command handler controller
       *  @param  function the command handler function
       */
      template <typename Controller>
      void stopCommandHandler(const std::string &name, Controller *pController,
                              void (Controller::*function)(const Buffer &command));

      /**
       *  @brief  Get a created service in this server
       *
       *  @param  name the service name
       */
      Service *service(const std::string &name) const;

      /**
       *  @brief  Get the signal processed on client exit
       */
      core::Signal<int> &onClientExit();

      /**
       *  @brief  Get the client id. To be used inside callbacks
       */
      int clientId() const;

      /**
      *  @brief  Get the dim dns node.
       *         First look at DimServer::getDnsNode() then
       *         environment variable "DIM_DNS_NODE"
       */
      static std::string dnsNode();

      /**
       *  @brief  Get the dim dns port
       */
      static int dnsPort();

      /**
       *  @brief  Get the list of running servers
       */
      static std::vector<std::string> runningServers();

      /**
       *  @brief  Whether the target server is already running on the network
       *
       *  @param  serverName the 'short' server name
       */
      static bool isServerRunning(const std::string &serverName);

      /**
       *  @brief  Whether the service is already running on the network
       *
       *  @param  name the service name
       */
      static bool serviceAlreadyRunning(const std::string &name);

      /**
       *  @brief  Whether the request handler is already running on the network
       *
       *  @param  name the request handler name
       */
      static bool requestHandlerAlreadyRunning(const std::string &name);

      /**
       *  @brief  Whether the command handler is already running on the network
       *
       *  @param  name the command handler name
       */
      static bool commandHandlerAlreadyRunning(const std::string &name);

    private:
      void handleServerInfoRequest(const Buffer &, Buffer &response);
      RequestHandler *requestHandler(const std::string &name) const;
      CommandHandler *commandHandler(const std::string &name) const;
      void clientExitHandler() override;
      void commandHandler() override {};

    private:
      typedef std::map<std::string, Service *> ServiceMap;
      typedef std::map<std::string, RequestHandler *> RequestHandlerMap;
      typedef std::map<std::string, CommandHandler *> CommandHandlerMap;

      std::string                   m_name = {""};             ///< The short server name
      bool                          m_started = {false};       ///< Whether the server has been started
      ServiceMap                    m_serviceMap = {};         ///< The map of registered services
      RequestHandlerMap             m_requestHandlerMap = {};  ///< The map of registered request handlers
      CommandHandlerMap             m_commandHandlerMap = {};  ///< The map of registered command handlers
      RequestHandler               *m_serverInfoHandler = {nullptr};  ///< The built-in request handler for server info
      core::Signal<int>             m_clientExitSignal = {};   ///< The signal emitted whenever a client exits
    };

    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------

    template <typename Controller>
    inline void Server::createRequestHandler(const std::string &rname, Controller *pController,
                                             void (Controller::*function)(const Buffer &request, Buffer &response)) {
      auto findIter = m_requestHandlerMap.find(rname);

      if (findIter != m_requestHandlerMap.end())
        throw std::runtime_error("Server::createRequestHandler(): request handler '" + rname +
                                 "' already exists in this client");

      if (Server::requestHandlerAlreadyRunning(rname))
        throw std::runtime_error("Server::createRequestHandler(): request handler '" + rname +
                                 "' already running on network");

      // first insert nullptr, then create request handler
      auto inserted = m_requestHandlerMap.insert(RequestHandlerMap::value_type(rname, nullptr));

      if (inserted.second) {
        RequestHandler *pRequestHandler = new RequestHandler(this, rname, pController, function);
        inserted.first->second = pRequestHandler;

        if (this->isRunning())
          pRequestHandler->startHandlingRequest();
      } else
        throw;
    }

    //-------------------------------------------------------------------------------------------------

    template <typename Controller>
    inline void Server::createCommandHandler(const std::string &cname, Controller *pController,
                                             void (Controller::*function)(const Buffer &command)) {
      auto findIter = m_commandHandlerMap.find(cname);

      if (findIter != m_commandHandlerMap.end()) {
        findIter->second->onCommand().connect(pController, function);

        if (this->isRunning())
          findIter->second->startHandlingCommands();

        return;
      }

      if (Server::commandHandlerAlreadyRunning(cname))
        throw std::runtime_error("Server::createCommandHandler(): command handler '" + cname +
                                 "' already running on network");

      // first insert nullptr, then create command handler
      auto inserted = m_commandHandlerMap.insert(CommandHandlerMap::value_type(cname, nullptr));

      if (inserted.second) {
        CommandHandler *pCommandHandler = new CommandHandler(this, cname, pController, function);
        inserted.first->second = pCommandHandler;

        if (this->isRunning())
          pCommandHandler->startHandlingCommands();
      } else
        throw;
    }

    //-------------------------------------------------------------------------------------------------

    template <typename Controller>
    inline void Server::stopCommandHandler(const std::string &cname, Controller *pController) {
      auto findIter = m_commandHandlerMap.find(cname);

      if (findIter != m_commandHandlerMap.end()) {
        findIter->second->onCommand().disconnect(pController);

        if (!findIter->second->onCommand().hasConnection())
          m_commandHandlerMap.erase(findIter);
      }
    }

    //-------------------------------------------------------------------------------------------------

    template <typename Controller>
    inline void Server::stopCommandHandler(const std::string &cname, Controller *pController,
                                           void (Controller::*function)(const Buffer &command)) {
      auto findIter = m_commandHandlerMap.find(cname);

      if (findIter != m_commandHandlerMap.end()) {
        findIter->second->onCommand().disconnect(pController, function);

        if (!findIter->second->onCommand().hasConnection())
          m_commandHandlerMap.erase(findIter);
      }
    }

  }
  
}

#endif //  SERVER_H
